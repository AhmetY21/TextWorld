#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class TWL2Buffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='#.*?$',
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(TWL2Buffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class TWL2Parser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='#.*?$',
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=TWL2Buffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(TWL2Parser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu()
    def _tag_(self):  # noqa
        self._pattern('[\\w()/!\\-\\s,.]+')

    @tatsumasu()
    def _given_(self):  # noqa
        self._pattern('([^;{}\\n\\[\\]<>])+')

    @tatsumasu()
    def _statement_(self):  # noqa
        self._pattern('([^|\\[\\]{}\\n<>])+')

    @tatsumasu()
    def _Literal_(self):  # noqa
        self._pattern('([^;|"<>\\[\\]{}\\n]+)?')

    @tatsumasu('Literal')
    def _literalAlternative_(self):  # noqa
        self._Literal_()
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('TerminalSymbol')
    def _TerminalSymbol_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('"')
                    self._Literal_()
                    self.name_last_node('literal')
                    self._token('"')
                with self._option():
                    self._Literal_()
                    self.name_last_node('literal')
                self._error('no available options')
        self.ast._define(
            ['literal'],
            []
        )

    @tatsumasu('NonterminalSymbol')
    def _NonterminalSymbol_(self):  # noqa
        self._pattern('<')
        self._tag_()
        self.name_last_node('symbol')
        self._token('>')
        self.ast._define(
            ['symbol'],
            []
        )

    @tatsumasu('EvalSymbol')
    def _evalSymbol_(self):  # noqa
        self._statement_()
        self.name_last_node('statement')
        self.ast._define(
            ['statement'],
            []
        )

    @tatsumasu('ConditionalSymbol')
    def _conditionalSymbol_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._NonterminalSymbol_()
                with self._option():
                    self._evalSymbol_()
                self._error('no available options')
        self.name_last_node('expression')
        with self._optional():
            self._token('|')
            self._given_()
            self.name_last_node('given')
        self.ast._define(
            ['expression', 'given'],
            []
        )

    @tatsumasu('SpecialSymbol')
    def _SpecialSymbol_(self):  # noqa
        self._pattern('\\{')
        self._conditionalSymbol_()
        self.name_last_node('statement')
        self._token('}')
        self.ast._define(
            ['statement'],
            []
        )

    @tatsumasu('ListSymbol')
    def _ListSymbol_(self):  # noqa
        self._pattern('\\[')

        def sep1():
            with self._group():
                self._pattern(',\\s*')

        def block1():
            with self._choice():
                with self._option():
                    self._SpecialSymbol_()
                with self._option():
                    self._NonterminalSymbol_()
                with self._option():
                    self._TerminalSymbol_()
                self._error('no available options')
        self._positive_gather(block1, sep1)
        self.name_last_node('symbols')
        self._token(']')
        self.ast._define(
            ['symbols'],
            []
        )

    @tatsumasu()
    def _Symbol_(self):  # noqa
        with self._choice():
            with self._option():
                self._ListSymbol_()
            with self._option():
                self._SpecialSymbol_()
            with self._option():
                self._NonterminalSymbol_()
            with self._option():
                self._TerminalSymbol_()
            self._error('no available options')

    @tatsumasu('AdjectiveNoun')
    def _adjectiveNoun_(self):  # noqa
        self._Literal_()
        self.name_last_node('adjective')
        self._token('|')
        self._Literal_()
        self.name_last_node('noun')
        self.ast._define(
            ['adjective', 'noun'],
            []
        )

    @tatsumasu()
    def _entity_(self):  # noqa
        with self._choice():
            with self._option():
                self._adjectiveNoun_()
            with self._option():
                self._literalAlternative_()
            self._error('no available options')

    @tatsumasu('Match')
    def _match_(self):  # noqa
        self._entity_()
        self.name_last_node('lhs')
        self._token('<->')
        self._entity_()
        self.name_last_node('rhs')
        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @tatsumasu('String')
    def _String_(self):  # noqa

        def block1():
            self._Symbol_()
        self._positive_closure(block1)
        self.name_last_node('symbols')
        self.ast._define(
            ['symbols'],
            []
        )

    @tatsumasu()
    def _alternatives_(self):  # noqa

        def sep0():
            self._token(';')

        def block0():
            self._String_()
        self._positive_gather(block0, sep0)

    @tatsumasu('ProductionRule')
    def _productionRule_(self):  # noqa
        self._tag_()
        self.name_last_node('symbol')
        self._token(':')
        self._alternatives_()
        self.name_last_node('alternatives')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('\n')
                with self._option():
                    self._check_eof()
                self._error('no available options')
        self.ast._define(
            ['alternatives', 'symbol'],
            []
        )

    @tatsumasu()
    def _onlyString_(self):  # noqa
        self._String_()
        self.name_last_node('@')
        self._check_eof()

    @tatsumasu()
    def _string_(self):  # noqa
        self._pattern('([^"])+')

    @tatsumasu()
    def _phName_(self):  # noqa
        self._pattern("[\\w']+")

    @tatsumasu()
    def _predName_(self):  # noqa
        self._pattern('!?[\\w/]+')

    @tatsumasu('PlaceholderNode')
    def _placeholder_(self):  # noqa
        self._phName_()
        self.name_last_node('name')
        with self._optional():
            self._token(':')
            self._phName_()
            self.name_last_node('type')
        self.ast._define(
            ['name', 'type'],
            []
        )

    @tatsumasu('PredicateNode')
    def _predicate_(self):  # noqa
        self._predName_()
        self.name_last_node('name')
        self._token('(')

        def sep2():
            self._token(',')

        def block2():
            self._placeholder_()
        self._gather(block2, sep2)
        self.name_last_node('parameters')
        self._token(')')
        self.ast._define(
            ['name', 'parameters'],
            []
        )

    @tatsumasu('ExpressionNode')
    @leftrec
    def _expression_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._conjunction_()
                with self._option():
                    self._disjunction_()
                with self._option():
                    self._predicate_()
                self._error('no available options')
        self.name_last_node('expression')
        self.ast._define(
            ['expression'],
            []
        )

    @tatsumasu('ConjunctionNode')
    @nomemo
    def _conjunction_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')

                def sep1():
                    self._token('&')

                def block1():
                    self._expression_()
                self._positive_gather(block1, sep1)
                self.name_last_node('expressions')
                self._token(')')
            with self._option():

                def sep3():
                    self._token('&')

                def block3():
                    self._expression_()
                self._positive_gather(block3, sep3)
                self.name_last_node('expressions')
            self._error('no available options')
        self.ast._define(
            ['expressions'],
            []
        )

    @tatsumasu('DisjunctionNode')
    @nomemo
    def _disjunction_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')

                def sep1():
                    self._token('|')

                def block1():
                    self._expression_()
                self._positive_gather(block1, sep1)
                self.name_last_node('expressions')
                self._token(')')
            with self._option():

                def sep3():
                    self._token('|')

                def block3():
                    self._expression_()
                self._positive_gather(block3, sep3)
                self.name_last_node('expressions')
            self._error('no available options')
        self.ast._define(
            ['expressions'],
            []
        )

    @tatsumasu()
    def _lhs_(self):  # noqa
        self._pattern('([a-zA-Z][a-zA-Z0-9.\\-_]*)')
        self.name_last_node('name')
        self.ast._define(
            ['name'],
            []
        )

    @tatsumasu('RhsNode')
    def _rhs_(self):  # noqa
        self._token('"')

        def block1():
            self._Symbol_()
        self._positive_closure(block1)
        self.name_last_node('symbols')
        self._token('"')
        with self._optional():
            self._token('|')
            self._token('"')
            self._string_()
            self.name_last_node('given')
            self._token('"')
        self.ast._define(
            ['given', 'symbols'],
            []
        )

    @tatsumasu('RuleNode')
    def _rule_(self):  # noqa
        self._lhs_()
        self.name_last_node('lhs')

        def block1():
            self._token('->')
            self._rhs_()
            self.name_last_node('rhs')
        self._positive_closure(block1)
        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @tatsumasu('GrammarNode')
    def _grammar_(self):  # noqa
        self._pattern('grammar\\s*\\{')

        def block1():
            self._rule_()
        self._positive_closure(block1)
        self.name_last_node('rules')
        self._token('}')
        self.ast._define(
            ['rules'],
            []
        )

    @tatsumasu()
    def _actionName_(self):  # noqa
        self._pattern('([a-zA-Z][a-zA-Z0-9.\\-_]*)')
        self.name_last_node('name')
        with self._optional():
            self._pattern('(\\([a-zA-Z0-9,\\-_ ]+\\))')
            self.name_last_node('params')
        self.ast._define(
            ['name', 'params'],
            []
        )

    @tatsumasu('ActionNode')
    def _action_(self):  # noqa
        self._actionName_()
        self.name_last_node('name')
        self._token(':')
        self._token('"')
        self._string_()
        self.name_last_node('template')
        self._token('"')
        self._token('->')
        self._token('"')
        self._string_()
        self.name_last_node('feedback')
        self._token('"')
        self.ast._define(
            ['feedback', 'name', 'template'],
            []
        )

    @tatsumasu('ActionsNode')
    def _actions_(self):  # noqa
        self._pattern('actions\\s*\\{')

        def block1():
            self._action_()
        self._positive_closure(block1)
        self.name_last_node('actions')
        self._token('}')
        self.ast._define(
            ['actions'],
            []
        )

    @tatsumasu('TWL2Document')
    def _twl2_(self):  # noqa
        self._grammar_()
        self.name_last_node('grammar')
        with self._optional():
            self._actions_()
            self.name_last_node('actions')
        self.ast._define(
            ['actions', 'grammar'],
            []
        )

    @tatsumasu()
    def _start_(self):  # noqa
        self._twl2_()

    @tatsumasu()
    def _onlyExpression_(self):  # noqa
        self._expression_()
        self.name_last_node('@')
        self._check_eof()


class TWL2Semantics(object):
    def tag(self, ast):  # noqa
        return ast

    def given(self, ast):  # noqa
        return ast

    def statement(self, ast):  # noqa
        return ast

    def Literal(self, ast):  # noqa
        return ast

    def literalAlternative(self, ast):  # noqa
        return ast

    def TerminalSymbol(self, ast):  # noqa
        return ast

    def NonterminalSymbol(self, ast):  # noqa
        return ast

    def evalSymbol(self, ast):  # noqa
        return ast

    def conditionalSymbol(self, ast):  # noqa
        return ast

    def SpecialSymbol(self, ast):  # noqa
        return ast

    def ListSymbol(self, ast):  # noqa
        return ast

    def Symbol(self, ast):  # noqa
        return ast

    def adjectiveNoun(self, ast):  # noqa
        return ast

    def entity(self, ast):  # noqa
        return ast

    def match(self, ast):  # noqa
        return ast

    def String(self, ast):  # noqa
        return ast

    def alternatives(self, ast):  # noqa
        return ast

    def productionRule(self, ast):  # noqa
        return ast

    def onlyString(self, ast):  # noqa
        return ast

    def string(self, ast):  # noqa
        return ast

    def phName(self, ast):  # noqa
        return ast

    def predName(self, ast):  # noqa
        return ast

    def placeholder(self, ast):  # noqa
        return ast

    def predicate(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def conjunction(self, ast):  # noqa
        return ast

    def disjunction(self, ast):  # noqa
        return ast

    def lhs(self, ast):  # noqa
        return ast

    def rhs(self, ast):  # noqa
        return ast

    def rule(self, ast):  # noqa
        return ast

    def grammar(self, ast):  # noqa
        return ast

    def actionName(self, ast):  # noqa
        return ast

    def action(self, ast):  # noqa
        return ast

    def actions(self, ast):  # noqa
        return ast

    def twl2(self, ast):  # noqa
        return ast

    def start(self, ast):  # noqa
        return ast

    def onlyExpression(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'tag'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = TWL2Parser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, TWL2Parser, name='TWL2')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
